// Q.4 Continuing the Q.2, You are provided with the following ciphertext, which was
// generated by applying the Affine Cipher to a plaintext that included a single-character
// salt added to each character before the encryption process.
// “TBRDOB RZWVUL TDMABRY VT H HPHCVUL TDMABRY”
// Your task is to:
// ● Determine the Affine Cipher keys (a and b) from the provided ciphertext.
// ○ Use frequency analysis to identify possible values of a and b.
// ○ Ensure that a is coprime with 26.
// ● Decrypt the ciphertext to retrieve the salted plaintext using the determined keys.
// ● Determine the salt value used in the process.
// ● Remove the salt from the decrypted text to recover the original plaintext.


#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <algorithm>
using namespace std;

// Get modular inverse of a under modulo 26
int modInverse(int a, int m = 26) {
    a = a % m;
    for (int x = 1; x < m; x++)
        if ((a * x) % m == 1)
            return x;
    return -1;
}

// Check if a is coprime with 26
bool isCoprime(int a) {
    for (int i = 2; i <= min(a, 26); i++) {
        if (a % i == 0 && 26 % i == 0)
            return false;
    }
    return true;
}

// Frequency analysis helper
void frequencyAnalysis(const string& text) {
    map<char, int> freq;
    for (char c : text) {
        if (isalpha(c))
            freq[toupper(c)]++;
    }

    cout << "Letter Frequencies:\n";
    for (auto& p : freq) {
        cout << p.first << ": " << p.second << "\n";
    }
}

// Try decrypting with guessed a and b
string decryptAffine(string cipher, int a, int b) {
    string decrypted = "";
    int a_inv = modInverse(a, 26);
    if (a_inv == -1) return "Invalid a";

    for (char c : cipher) {
        if (isalpha(c)) {
            int y = toupper(c) - 'A';
            int x = (a_inv * (y - b + 26)) % 26;
            decrypted += (x + 'A');
        } else {
            decrypted += c;
        }
    }
    return decrypted;
}

// Remove salt from decrypted salted plaintext
string removeSalt(string salted, int salt) {
    string plain = "";
    for (char c : salted) {
        if (isalpha(c)) {
            int x = (toupper(c) - 'A' - salt + 26) % 26;
            plain += (x + 'A');
        } else {
            plain += c;
        }
    }
    return plain;
}

int main() {
    string cipher = "TBRDOB RZWVUL TDMABRY VT H HPHCVUL TDMABRY";

    // Step 1: Frequency Analysis
    cout << "Ciphertext:\n" << cipher << "\n\n";
    frequencyAnalysis(cipher);
    cout << "\n";

    // Step 2: Try candidate (a, b) pairs
    vector<int> a_values = {1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25}; // Valid a values (coprime with 26)
    
    for (int a : a_values) {
        for (int b = 0; b < 26; b++) {
            string trial = decryptAffine(cipher, a, b);
            cout << "Trying a=" << a << ", b=" << b << ":\n";
            cout << trial << "\n\n";
        }
    }

    // Step 3: Manually identify correct decryption from output and determine salt
    // Once you find the correct salted plaintext, try salt values:
    string decrypted_with_salt = "JGNNQ"; // Replace with correct guess from above loop
    for (int salt = 0; salt < 26; salt++) {
        string guess = removeSalt(decrypted_with_salt, salt);
        cout << "Salt = " << salt << " → " << guess << "\n";
    }

    return 0;
}
